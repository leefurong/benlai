<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Benlai - Proof of Concept</title>
</head>
<body>
    <div id="app">Loading...</div>

    <script>
        // Minimal Benlai Client Runtime
        // Browser has NO business logic, NO state - only UI rendering
        const app = document.getElementById('app');
        
        // Hiccup to HTML converter (pure UI transformation)
        function hiccupToHtml(hiccup) {
            // Handle null, undefined, boolean
            if (hiccup === null || hiccup === undefined) {
                return '';
            }
            
            if (typeof hiccup === 'boolean') {
                return '';
            }
            
            if (typeof hiccup === 'string' || typeof hiccup === 'number') {
                return String(hiccup);
            }
            
            if (!Array.isArray(hiccup)) {
                // If it's an object but not an array, it's likely an error
                console.warn('hiccupToHtml: unexpected non-array value:', hiccup);
                return '';
            }
            
            if (hiccup.length === 0) {
                return '';
            }
            
            const [tag, ...rest] = hiccup;
            
            // Handle text nodes
            if (typeof tag === 'string' && rest.length === 0) {
                return tag;
            }
            
            // Handle elements: [tag, attrs?, ...children]
            let attrs = {};
            let children = [];
            
            if (rest.length > 0 && typeof rest[0] === 'object' && !Array.isArray(rest[0]) && rest[0] !== null) {
                // Has attributes
                attrs = rest[0];
                children = rest.slice(1);
            } else {
                // No attributes
                children = rest;
            }
            
            // Build attributes string
            let attrsStr = '';
            for (const [key, value] of Object.entries(attrs)) {
                // For data attributes, we need to escape HTML but preserve JSON strings
                if (key === 'data-handler' || key.startsWith('data-')) {
                    // Escape HTML entities but preserve the string structure
                    const escapedValue = String(value)
                        .replace(/&/g, '&amp;')
                        .replace(/</g, '&lt;')
                        .replace(/>/g, '&gt;')
                        .replace(/"/g, '&quot;')
                        .replace(/'/g, '&#39;');
                    attrsStr += ` ${key}="${escapedValue}"`;
                } else if (key === 'style' && typeof value === 'string') {
                    attrsStr += ` style="${escapeHtml(value)}"`;
                } else if (key.startsWith('on-')) {
                    // Event handlers: distinguish between client-side JS and server handlers
                    // Server handlers are vectors converted to JSON strings (start with [)
                    // Client-side handlers are plain JavaScript strings
                    const valueStr = String(value);
                    const trimmed = valueStr.trim();
                    
                    if (Array.isArray(value) || (trimmed.startsWith('[') && trimmed.endsWith(']'))) {
                        // Server handler: vector format (array or JSON string)
                        // Use same escaping as data-handler (preserve JSON structure)
                        const jsonValue = Array.isArray(value) ? JSON.stringify(value) : valueStr;
                        const escapedValue = jsonValue
                            .replace(/&/g, '&amp;')
                            .replace(/</g, '&lt;')
                            .replace(/>/g, '&gt;')
                            .replace(/"/g, '&quot;')
                            .replace(/'/g, '&#39;');
                        attrsStr += ` data-${key}="${escapedValue}"`;
                    } else {
                        // Client-side handler: plain JavaScript code
                        // Use native browser on-* attribute for direct execution
                        const jsCode = valueStr
                            .replace(/"/g, '&quot;')
                            .replace(/'/g, '&#39;');
                        attrsStr += ` ${key}="${jsCode}"`;
                    }
                } else if (typeof value === 'string' || typeof value === 'number') {
                    attrsStr += ` ${key}="${escapeHtml(String(value))}"`;
                }
            }
            
            // Render children - filter out null/undefined and handle each child
            const childrenHtml = children
                .filter(child => {
                    // Filter out null, undefined, and non-renderable values
                    if (child === null || child === undefined) return false;
                    if (typeof child === 'boolean') return false;
                    // Allow strings, numbers, arrays (Hiccup vectors)
                    return typeof child === 'string' || 
                           typeof child === 'number' || 
                           Array.isArray(child);
                })
                .map(child => {
                    try {
                        const result = hiccupToHtml(child);
                        // Ensure result is a string
                        return typeof result === 'string' ? result : '';
                    } catch (error) {
                        console.warn('Error rendering child:', child, error);
                        return '';
                    }
                })
                .join('');
            
            // Self-closing tags
            const selfClosing = ['img', 'br', 'hr', 'input', 'meta', 'link'];
            if (selfClosing.includes(tag)) {
                return `<${tag}${attrsStr} />`;
            }
            
            return `<${tag}${attrsStr}>${childrenHtml}</${tag}>`;
        }
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // Render Hiccup tree to DOM
        function renderHiccup(hiccup) {
            const html = hiccupToHtml(hiccup);
            app.innerHTML = html;
            attachEventListeners();
        }
        
        // Resolve parameter expression to actual value
        // Supports: "input[name].value", "#id.value", "[data-x].dataset.x", etc.
        function resolveParam(expr, contextElement) {
            if (typeof expr !== 'string') {
                return expr; // Already a literal value
            }
            
            // Check if it's an expression (contains selector)
            if (!expr.includes('.') && !expr.includes('[') && !expr.startsWith('#')) {
                return expr; // Plain string literal
            }
            
            try {
                // Parse selector and property path
                // Format: "selector.property.path" or "selector[attr].property.path"
                let selector, propertyPath;
                
                // Handle attribute selector: [name="x"]
                if (expr.startsWith('[')) {
                    const bracketEnd = expr.indexOf(']');
                    if (bracketEnd === -1) return expr;
                    selector = expr.substring(0, bracketEnd + 1);
                    propertyPath = expr.substring(bracketEnd + 2); // Skip '].'
                }
                // Handle ID selector: #id
                else if (expr.startsWith('#')) {
                    const dotIndex = expr.indexOf('.');
                    if (dotIndex === -1) return expr;
                    selector = expr.substring(0, dotIndex);
                    propertyPath = expr.substring(dotIndex + 1);
                }
                // Handle tag selector: input, button, etc.
                else {
                    const dotIndex = expr.indexOf('.');
                    if (dotIndex === -1) return expr;
                    selector = expr.substring(0, dotIndex);
                    propertyPath = expr.substring(dotIndex + 1);
                }
                
                // Find element
                let element;
                if (selector.startsWith('#')) {
                    element = document.getElementById(selector.substring(1));
                } else if (selector.startsWith('[')) {
                    // Attribute selector: [name="x"] or [name]
                    const match = selector.match(/\[([^=]+)(?:="([^"]+)")?\]/);
                    if (match) {
                        const attrName = match[1];
                        const attrValue = match[2];
                        if (attrValue) {
                            element = app.querySelector(`[${attrName}="${attrValue}"]`);
                        } else {
                            element = app.querySelector(`[${attrName}]`);
                        }
                    }
                } else {
                    // Tag selector: find within context or app
                    const searchRoot = contextElement?.closest('form') || contextElement?.parentElement || app;
                    element = searchRoot.querySelector(selector);
                }
                
                if (!element) {
                    console.warn(`Element not found for selector: ${selector}`);
                    return null;
                }
                
                // Navigate property path
                const props = propertyPath.split('.');
                let value = element;
                for (const prop of props) {
                    if (value == null) return null;
                    
                    // Handle dataset access: dataset.x -> data-x
                    if (prop === 'dataset') {
                        value = value.dataset;
                    }
                    // Handle attributes: getAttribute('x')
                    else if (prop.startsWith('attr:')) {
                        const attrName = prop.substring(5);
                        value = value.getAttribute(attrName);
                    }
                    // Handle standard properties
                    else {
                        value = value[prop];
                    }
                }
                
                return value;
            } catch (error) {
                console.warn(`Failed to resolve param expression: ${expr}`, error);
                return expr; // Return as-is if resolution fails
            }
        }
        
        // Parse event handler (supports both string and vector format)
        function parseEventHandler(handlerAttr) {
            if (!handlerAttr) return null;
            
            // Trim whitespace
            handlerAttr = handlerAttr.trim();
            
            // Check if it looks like a JSON array (starts with [ and ends with ])
            // Must have both to be considered a vector format
            if (handlerAttr.startsWith('[') && handlerAttr.endsWith(']')) {
                try {
                    // Try parsing as JSON array (vector format)
                    const parsed = JSON.parse(handlerAttr);
                    if (Array.isArray(parsed) && parsed.length > 0) {
                        return {
                            handler: parsed[0],
                            params: parsed.slice(1)
                        };
                    } else {
                        console.warn('Parsed JSON is not a valid handler array:', parsed);
                        return null;
                    }
                } catch (e) {
                    console.error('Failed to parse handler as JSON array:', handlerAttr, e);
                    // If it looks like JSON but fails to parse, it's an error - don't fall through
                    return null;
                }
            }
            
            // If it starts with [ but doesn't end with ], it's likely a truncated JSON string
            // Don't treat it as a simple string handler - return null to indicate error
            if (handlerAttr.startsWith('[') && !handlerAttr.endsWith(']')) {
                console.error('Handler appears to be truncated JSON:', handlerAttr);
                return null;
            }
            
            // Simple string format (for legacy handlers or plain JS code)
            // Only use this if it's clearly not a JSON array
            return {
                handler: handlerAttr,
                params: []
            };
        }
        
        // Resolve all parameters in event vector
        function resolveEventParams(params, contextElement) {
            return params.map(param => resolveParam(param, contextElement));
        }
        
        async function sendEvent(eventSpec, contextElement = null) {
            try {
                // Validate eventSpec
                if (!eventSpec || !eventSpec.handler) {
                    throw new Error('Invalid event handler: eventSpec is null or missing handler');
                }
                
                console.log('sendEvent - eventSpec:', eventSpec); // Debug
                
                // Resolve parameters
                const resolvedParams = resolveEventParams(eventSpec.params || [], contextElement);
                console.log('sendEvent - resolvedParams:', resolvedParams); // Debug
                
                // Build payload: handler + resolved params as object
                const payload = {
                    handler: eventSpec.handler,
                    ...(resolvedParams.length > 0 ? { params: resolvedParams } : {})
                };
                
                console.log('sendEvent - payload:', payload); // Debug
                
                const response = await fetch('/api/event', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(payload)
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                // Server returns Hiccup tree (as JSON) - browser converts to HTML
                const hiccup = await response.json();
                renderHiccup(hiccup);
            } catch (error) {
                console.error('Failed to send event:', error);
                app.innerHTML = '<p style="color: red;">Error: ' + error.message + '</p>';
            }
        }
        
        function attachEventListeners() {
            // Support both standard on-* attributes and legacy data-handler
            // Hiccup converts :on-click to "on-click" (with hyphen) in JSON
            // Map hyphenated event names to browser event types
            // Note: Only server handlers (vector format) are attached here
            // Client-side handlers (plain JS strings) are handled by browser natively
            const eventNameMap = {
                'on-click': 'click',
                'on-submit': 'submit',
                'on-change': 'change',
                'on-input': 'input',
                'on-focus': 'focus',
                'on-blur': 'blur',
                'on-mouseover': 'mouseover',
                'on-mouseout': 'mouseout'
            };
            
            // Attach handlers for server events (only data-on-* attributes with vector format)
            for (const [attrName, eventType] of Object.entries(eventNameMap)) {
                const elements = app.querySelectorAll(`[data-${attrName}]`);
                elements.forEach(element => {
                    const handlerAttr = element.getAttribute(`data-${attrName}`);
                    if (!handlerAttr) return;
                    
                    // Only process if it's a vector format (starts with [)
                    // Plain JS strings are handled by browser's native on-* attributes
                    const trimmed = handlerAttr.trim();
                    if (!trimmed.startsWith('[')) return;
                    
                    // Debug: log the raw attribute value
                    console.log(`Parsing handler for ${attrName}:`, trimmed);
                    console.log(`Handler attribute length:`, trimmed.length);
                    console.log(`Handler attribute first char:`, trimmed[0]);
                    console.log(`Handler attribute last char:`, trimmed[trimmed.length - 1]);
                    
                    const eventSpec = parseEventHandler(handlerAttr);
                    if (eventSpec && eventSpec.handler) {
                        console.log(`Parsed event spec:`, eventSpec);
                        element.addEventListener(eventType, (e) => {
                            // Only preventDefault for form submissions and links
                            if (eventType === 'submit' || (eventType === 'click' && element.tagName === 'A')) {
                                e.preventDefault();
                            }
                            sendEvent(eventSpec, element);
                        });
                    } else {
                        console.error(`Failed to parse handler for ${attrName}. Raw value:`, handlerAttr);
                        console.error(`Trimmed value:`, trimmed);
                        console.error(`Is array-like:`, trimmed.startsWith('[') && trimmed.endsWith(']'));
                    }
                });
            }
            
            // Legacy support: data-handler for click events
            const clickable = app.querySelectorAll('[data-handler]');
            clickable.forEach(element => {
                // Skip if already handled by on-click
                if (element.hasAttribute('data-on-click')) return;
                
                const handlerAttr = element.getAttribute('data-handler');
                if (!handlerAttr) return;
                
                const eventSpec = parseEventHandler(handlerAttr);
                if (eventSpec) {
                    element.addEventListener('click', (e) => {
                        e.preventDefault();
                        sendEvent(eventSpec, element);
                    });
                }
            });
        }
        
        // Initialize: render server-provided Hiccup on page load
        document.addEventListener('DOMContentLoaded', () => {
            const hiccupData = app.getAttribute('data-hiccup');
            if (hiccupData) {
                try {
                    const hiccup = JSON.parse(hiccupData);
                    renderHiccup(hiccup);
                } catch (error) {
                    console.error('Failed to parse initial Hiccup:', error);
                }
            } else {
                attachEventListeners();
            }
        });
    </script>
</body>
</html>


